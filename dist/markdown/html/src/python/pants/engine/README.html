<!-- generated by pants! -->

<style>
.codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f0f0f0; }
.codehilite .c { color: #60a0b0; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #007020; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #007020 } /* Comment.Preproc */
.codehilite .c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #808080 } /* Generic.Output */
.codehilite .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0040D0 } /* Generic.Traceback */
.codehilite .kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #007020 } /* Keyword.Pseudo */
.codehilite .kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #902000 } /* Keyword.Type */
.codehilite .m { color: #40a070 } /* Literal.Number */
.codehilite .s { color: #4070a0 } /* Literal.String */
.codehilite .na { color: #4070a0 } /* Name.Attribute */
.codehilite .nb { color: #007020 } /* Name.Builtin */
.codehilite .nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.codehilite .no { color: #60add5 } /* Name.Constant */
.codehilite .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.codehilite .ni { color: #d55537; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #007020 } /* Name.Exception */
.codehilite .nf { color: #06287e } /* Name.Function */
.codehilite .nl { color: #002070; font-weight: bold } /* Name.Label */
.codehilite .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #062873; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #bb60d5 } /* Name.Variable */
.codehilite .ow { color: #007020; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mf { color: #40a070 } /* Literal.Number.Float */
.codehilite .mh { color: #40a070 } /* Literal.Number.Hex */
.codehilite .mi { color: #40a070 } /* Literal.Number.Integer */
.codehilite .mo { color: #40a070 } /* Literal.Number.Oct */
.codehilite .sb { color: #4070a0 } /* Literal.String.Backtick */
.codehilite .sc { color: #4070a0 } /* Literal.String.Char */
.codehilite .sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #4070a0 } /* Literal.String.Double */
.codehilite .se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #4070a0 } /* Literal.String.Heredoc */
.codehilite .si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.codehilite .sx { color: #c65d09 } /* Literal.String.Other */
.codehilite .sr { color: #235388 } /* Literal.String.Regex */
.codehilite .s1 { color: #4070a0 } /* Literal.String.Single */
.codehilite .ss { color: #517918 } /* Literal.String.Symbol */
.codehilite .bp { color: #007020 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #bb60d5 } /* Name.Variable.Class */
.codehilite .vg { color: #bb60d5 } /* Name.Variable.Global */
.codehilite .vi { color: #bb60d5 } /* Name.Variable.Instance */
.codehilite .il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>

<h1 id="the-new-engine">The New Engine</h1>
<h2 id="scheduling">Scheduling</h2>
<p>In the current RoundEngine, work is scheduled and then later performed via the <code>Task</code> interface. In
the new engine execution occurs via simple functions, with inputs selected via an input
selection clause made up of <code>Selector</code> objects (described later).</p>
<h2 id="history">History</h2>
<p>The need for an engine that could schedule all work as a result of linking required products to
their producers in multiple rounds was identified sometime in the middle of 2013 as a result of
new requirements on the <code>IdeaGen</code> task forced by the use of pants in the Twitter birdcage repo.  The
design document for this "RoundEngine" is
<a href="https://docs.google.com/document/d/1MwOFcr4W6KbzPdbaj_ntJ36a0NRoiKyWLed0ziobsr4/edit#heading=h.rsohbvtm7zng">here</a>.
Some work was completed along these lines and an initial version of the <code>RoundEngine</code> was
integrated into the pants mainline and is used today.</p>
<p>Work stalled on the later phases of the <code>RoundEngine</code> and talks re-booted about the future of the
<code>RoundEngine</code>.  Foursquare folks had been thinking about general problems with the <code>RoundEngine</code> as
it stood and proposed the idea of a "tuple-engine".  With some license taken in representation, this
idea took the <code>RoundEngine</code> to the extreme of generating a round for each target-task pair.  The
pair formed the tuple of schedulable work and this concept combined with others to form the design
[here][tuple-design].</p>
<p>Meanwhile, need for fine-grained parallelism was acute to help speed up jvm compilation, especially
in the context of scala and mixed scala &amp; java builds.  Twitter spiked on a project to implement
a target-level scheduling system scoped to just the jvm compilation tasks.  This bore fruit and
served as further impetus to get a "tuple-engine" designed and constructed to bring the benefits
seen in the jvm compilers to the wider pants world of tasks.</p>
<h3 id="api">API</h3>
<h4 id="end-user-api">End User API</h4>
<p>The end user API for the engine is based on the registration of <code>Rules</code>, which are made up of:</p>
<ol>
<li>a <code>Product</code> or return type of a function,</li>
<li>a list of dependency <code>Selectors</code> which match inputs to the function,</li>
<li>the function itself.</li>
</ol>
<p>A <code>Rule</code> fully declares the inputs and outputs for its function: there is no imperative API for
requesting additional inputs during execution of a function. While a tight constraint,
this has the advantage of forcing decomposition of work into functions which are loosely
coupled by only the types of their inputs and outputs, and which are naturally isolated, cacheable,
and parallelizable.</p>
<p>A function is guaranteed to execute only when all of its inputs are ready for use. The Scheduler
considers executing a Rule when it determines that it needs to produce the declared
output <code>Product</code> type of that function for a particular <code>Subject</code>. But the Scheduler will only
actually run a Rule if it is able to (recursively) find sources for each of the
function's inputs.</p>
<p>See below for more information on <code>Products</code>, <code>Subjects</code>, and <code>Selectors</code>.</p>
<h4 id="internal-api">Internal API</h4>
<p>Internally, the <code>Scheduler</code> uses end user <code>Rules</code> to create private <code>Node</code> objects and
build a <code>Graph</code> of futures that links them to their dependency Nodes. A Node represents a unique
computation and the data for a Node implicitly acts as its own key/identity.</p>
<p>To compute a value for a Node, the Scheduler uses the <code>Node.run</code> method starting from requested
roots. If a Node needs more inputs, it requests them via <code>Context.get</code>, which will declare a
dependency, and memoize the computation represented by the <code>Node</code>.</p>
<p>The initial Nodes are <a href="https://github.com/pantsbuild/pants/blob/16d43a06ba3751e22fdc7f69f009faeb59a33930/src/rust/engine/src/scheduler.rs#L116-L126">launched by the scheduler</a>,
but the rest of the scheduling is driven by Nodes recursively calling <code>Context.get</code> to request
dependencies.</p>
<h3 id="products-and-subjects">Products and Subjects</h3>
<p>A <code>Product</code> is a strongly typed value specific to a particular <code>Subject</code>. End user Rules execute
in order to (recursively) compute a Product for a Subject: as a very simple example, one might
register the following Rule that can compute a <code>String</code> Product given a single <code>Int</code> input
by calling the <code>str</code> function:</p>
<div class="codehilite"><pre>@rule(StringType, [Select(IntType)])
def int_to_str(an_int):
  return str(an_int)
</pre></div>


<p>When the Scheduler wants to decide whether it can use this Rule to create a string for a
Subject, it will first see whether there are any ways to get an IntType for that Subject. If
the subject is already of <code>type(subject) == IntType</code>, then the Rule will be able to
execute immediately. On the other hand, if the type <em>doesn't</em> match, the Scheduler doesn't give up:
it will next look for any other registered Rules that can compute an IntType Product for the
Subject (and so on, recursively.)</p>
<p>This recursive type search leads to some very interesting (and, admittedly, somewhat "magical")
properties. If there is any path through the Rule graph that allows for conversion
from one type to another, it will be found and executed.</p>
<h3 id="selectors">Selectors</h3>
<p>As demonstrated above, the <code>Selector</code> classes select function inputs in the context of a particular
<code>Subject</code> (and its <code>Variants</code>: discussed below). For example, it might select a <code>Product</code> for the given
Subject (<code>Select</code>), or for other Subject(s) selected from fields of a Product (<code>SelectDependencies</code>,
<code>SelectProjection</code>).</p>
<p>One very important thing to keep in mind is that Selectors like <code>SelectDependencies</code> and <code>SelectProjection</code>
"change" the Subject within a particular subgraph. For example, <code>SelectDependencies</code>
results in new subgraphs for each Subject in a list of values that was computed for some original Subject.
Concretely, a Rule could use SelectDependencies to select FileContent for each entry in a Files list,
and then concatentate that content into a string:</p>
<div class="codehilite"><pre>@rule(StringType, [SelectDependencies(FileContent, Files)])
def concat(file_content_list):
  return &#39;&#39;.join(fc.content for fc in file_content_list)
</pre></div>


<p>This Rule declares that: "for any Subject for which we can compute a 'Files' object, we can also
compute a StringType". Each subgraph will contain an attempt to get FileContent for a different
File Subject from the Files list.</p>
<p>In practical use, using <code>StringType</code> or <code>IntType</code> directly would probably not provide enough information
to disambiguate between various types of data: So declaring small <code>datatype</code> definitions to provide
a unique and descriptive type is strongly recommended:</p>
<div class="codehilite"><pre>class ConcattedFiles(datatype(&#39;ConcattedFiles&#39;, [&#39;content&#39;])):
  pass
</pre></div>


<h3 id="variants">Variants</h3>
<p>Certain Rules will also need parameters provided by their dependents in order to tailor their output
Products to their consumers.  For example, a javac planner might need to know
the version of the java platform for a given dependent binary target (say Java 6), or an ivy Rule
might need to identify a globally consistent ivy resolve for a test target.  To allow for this the
engine introduces the concept of <code>variants</code>, which are passed recursively from dependents to
dependencies.</p>
<p>If a Rule uses a <code>SelectVariants</code> Selector to indicate that a variant is required, consumers can use
a <code>@[type]=[name]</code> address syntax extension to pass a variant that matches a particular configuration
for a Rule. A dependency declared as <code>src/java/com/example/lib:lib</code> specifies no particular variant, but
<code>src/java/com/example/lib:lib@java=java8</code> asks for the configured variant of the lib named "java8".</p>
<p>Additionally, it is possible to specify the "default" variants for an Address by installing a Rule
function that can provide <code>Variants(default=..)</code>. Again, since the purpose of variants is to collect
information from dependents, only default variant values which have not been set by a dependent
will be used.</p>
<h2 id="execution">Execution</h2>
<p>The Scheduler executes work concurrently wherever possible; to help visualize executions, a visualization
tool is provided that, after executing a <code>ProductGraph</code>, generates a <code>dot</code> file that can be rendered using
Graphviz:</p>
<div class="codehilite"><pre><span class="gp">$</span> mkdir viz
<span class="gp">$</span> ./pants --native-engine-visualize-to<span class="o">=</span>viz list some/example/directory:
<span class="gp">$</span> ls viz
<span class="go">run.0.dot</span>
</pre></div>


<h2 id="native-engine">Native Engine</h2>
<p>The native engine is integrated into the pants codebase via <code>native.py</code> in
this directory along with <code>build-support/bin/native/bootstrap.sh</code> which ensures a
pants native engine library is built and available for linking. The glue is the
sha1 hash of the native engine source code used as its version by the <code>Native</code>
class. This hash is maintained by <code>build-support/bin/native/bootstrap.sh</code> and
output to the <code>native_engine_version</code> file in this directory. Any modification
to this resource file's location will need adjustments in
<code>build-support/bin/native/bootstrap.sh</code> to ensure the linking continues to work.</p>
