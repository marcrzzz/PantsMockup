<!-- generated by pants! -->

<style>
.codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f0f0f0; }
.codehilite .c { color: #60a0b0; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #007020; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #007020 } /* Comment.Preproc */
.codehilite .c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #808080 } /* Generic.Output */
.codehilite .gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0040D0 } /* Generic.Traceback */
.codehilite .kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #007020 } /* Keyword.Pseudo */
.codehilite .kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #902000 } /* Keyword.Type */
.codehilite .m { color: #40a070 } /* Literal.Number */
.codehilite .s { color: #4070a0 } /* Literal.String */
.codehilite .na { color: #4070a0 } /* Name.Attribute */
.codehilite .nb { color: #007020 } /* Name.Builtin */
.codehilite .nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.codehilite .no { color: #60add5 } /* Name.Constant */
.codehilite .nd { color: #555555; font-weight: bold } /* Name.Decorator */
.codehilite .ni { color: #d55537; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #007020 } /* Name.Exception */
.codehilite .nf { color: #06287e } /* Name.Function */
.codehilite .nl { color: #002070; font-weight: bold } /* Name.Label */
.codehilite .nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #062873; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #bb60d5 } /* Name.Variable */
.codehilite .ow { color: #007020; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mf { color: #40a070 } /* Literal.Number.Float */
.codehilite .mh { color: #40a070 } /* Literal.Number.Hex */
.codehilite .mi { color: #40a070 } /* Literal.Number.Integer */
.codehilite .mo { color: #40a070 } /* Literal.Number.Oct */
.codehilite .sb { color: #4070a0 } /* Literal.String.Backtick */
.codehilite .sc { color: #4070a0 } /* Literal.String.Char */
.codehilite .sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #4070a0 } /* Literal.String.Double */
.codehilite .se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #4070a0 } /* Literal.String.Heredoc */
.codehilite .si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.codehilite .sx { color: #c65d09 } /* Literal.String.Other */
.codehilite .sr { color: #235388 } /* Literal.String.Regex */
.codehilite .s1 { color: #4070a0 } /* Literal.String.Single */
.codehilite .ss { color: #517918 } /* Literal.String.Symbol */
.codehilite .bp { color: #007020 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #bb60d5 } /* Name.Variable.Class */
.codehilite .vg { color: #bb60d5 } /* Name.Variable.Global */
.codehilite .vi { color: #bb60d5 } /* Name.Variable.Instance */
.codehilite .il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>

<h1 id="jvm-projects-with-pants">JVM Projects with Pants</h1>
<p>Assuming you know the basic
<a href="../../../../../../src/docs/first_concepts.html">Pants concepts</a>
and have gone through the
<a href="../../../../../../src/docs/first_tutorial.html">first Tutorial</a>,
you've made a great start towards
using Pants to work with Java and Scala code. This page goes into some
of the details.</p>
<p>If you are accustomed to the Maven tool and contemplating moving to
Pants, you are not alone;
<a href="from_maven.html">Pants for Maven Experts</a>
has some advice.</p>
<h2 id="relevant-goals-and-targets">Relevant Goals and Targets</h2>
<p>When working with JVM languages, the following goals and targets are
especially relevant.</p>
<p><strong>Deployable Bundle</strong> <em>Runnable Binary, optionally with non-JVM files</em></p>
<blockquote>
<p>Deployable bundles are directories, optionally archived, that contain
all files necessary to run the application. The <code>bundle</code> goal is used
to create these deployable bundles from either <code>jvm_binary</code> or
<code>jvm_app</code> targets.</p>
<p>Bundling a <code>jvm_binary</code> target is appropriate when your application is
entirely jar-based; that is, it's entirely class files and resources
packaged inside the jars themselves. If your application requires
"extra stuff" (e.g.: start scripts, config files) use a <code>jvm_app</code>
which allows you to include files in the bundle directory that
supplement the binary jar and its dependencies. You can learn
more about <a pantsref="jvm_bundles">bundles</a>.</p>
</blockquote>
<p><strong>Runnable Binary</strong></p>
<blockquote>
<p>On its own, a <code>jvm_binary</code> BUILD target describes an executable <code>.jar</code>
(something you can run with <code>java -jar</code>). The jar is described as
executable because it contains a manifest file that specifies the main
class as well as classpath for all dependencies. If your program
contains only jars (and resources packaged in those jars), this is all
you need to run the binary. Use <code>./pants binary</code> to compile its
code; <code>./pants run</code> to run it "in place".</p>
</blockquote>
<p><strong>Importable Code</strong></p>
<blockquote>
<p><code>java_library</code> BUILD targets make Java source code <code>import</code>-able. The
rule of thumb is that each directory of <code>.java</code> files has a <code>BUILD</code>
file with a <code>java_library</code> target. A JVM target that has a
<code>java_library</code> in its <code>dependencies</code> can import its code.
<code>scala_library</code> targets are similar, but compiled with Scala.</p>
<p>To use pre-built <code>.jar</code>s, a JVM target can depend on a <code>jar</code>, a
reference to published code; these <code>jar</code>s normally live in a
directory called
<a href="3rdparty_jvm.html">3rdparty</a>.</p>
<p>Pants can <code>publish</code> a JVM library so code in other repos can use it;
if the <code>*_library</code> target has a <code>provides</code> parameter, that specifies
the repo/address at which to <a href="publish.html">publish</a>.</p>
<p>An <code>annotation_processor</code> BUILD target defines a Java library one
containing one or more annotation processors.</p>
</blockquote>
<p><strong>Tests</strong></p>
<blockquote>
<p>A <code>junit_tests</code> BUILD target holds source code for some JUnit tests;
typically, it would have one or more <code>java_library</code> targets as
dependencies and would import and test their code.</p>
<p>Pants also includes support for using the ScalaTest framework.  The
testing framework automatically picks up scala tests that extend the
org.scalatest.Suite class and runs them
using org.scalatest.junit.JUnitRunner.</p>
<p>Most other scala test frameworks support running with JUnit via a base
class/trait or via a <code>@RunWith</code> annotation; so you can use
<code>junit_tests</code> for your scala tests as well.</p>
<p>The Pants <code>test</code> goal runs tests.</p>
</blockquote>
<p><strong>Generated Code</strong></p>
<blockquote>
<p>A <code>java_thrift_library</code> generates Java code from <code>.thrift</code> source; a
JVM target that has this target in its <code>dependencies</code> can <code>import</code> the
generated Java code. A <code>java_protobuf_library</code> is similar, but
generates Java code from protobuffer source. A <code>jaxb_library</code>
definition generates code to read and write XML using an XML schema
(.xsd files).</p>
</blockquote>
<h2 id="build-for-a-simple-binary">BUILD for a Simple Binary</h2>
<p>The <a href="https://github.com/pantsbuild/pants/tree/master/examples/src/java/org/pantsbuild/example/hello">Pants Build Java hello world
sample</a>
code shows the BUILD file for a simple Java binary (in the <code>main/</code>
directory):</p>
<p>
<div class="md-included-snippet"><div class="codehilite"><pre><span class="n">jvm_binary</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;main-bin&#39;</span><span class="p">,</span>
  <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;examples/src/java/org/pantsbuild/example/hello/greet&#39;</span><span class="p">,</span>
    <span class="s">&#39;examples/src/resources/org/pantsbuild/example/hello&#39;</span><span class="p">,</span>
  <span class="p">],</span>
  <span class="n">source</span> <span class="o">=</span> <span class="s">&#39;HelloMain.java&#39;</span><span class="p">,</span>
  <span class="n">main</span> <span class="o">=</span> <span class="s">&#39;org.pantsbuild.example.hello.main.HelloMain&#39;</span><span class="p">,</span>
  <span class="n">basename</span> <span class="o">=</span> <span class="s">&#39;hello-example&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div></div>
</p>
<p>This small program has just one dependency. It is a library, a <code>java_library</code>, a compiled set of
source code from this workspace.</p>
<h3 id="depending-on-a-library">Depending on a Library</h3>
<p>The rule of thumb is that each directory of <code>.java</code> or <code>.scala</code> files
has a library target. If you find yourself thinking "we should move some
of this code to another directory," you probably also want to set up a
<code>BUILD</code> file with a <code>java_library</code> (or <code>scala_library</code>) target. Here we
see the library target which <code>main-bin</code> depends on. This library target
lives in <code>hello/greet/BUILD</code>:</p>
<p>
<div class="md-included-snippet"><div class="codehilite"><pre><span class="c"># Note that the target has no explicit name, so it defaults to the name</span>
<span class="c"># of the directory, in this case &#39;greet&#39;.</span>
<span class="c"># It also has no explicit sources, so it defaults to the sources implied</span>
<span class="c"># by the target type, in this case &quot;globs(&#39;*.java&#39;)&quot;.</span>
<span class="n">java_library</span><span class="p">(</span>
  <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[],</span> <span class="c"># A more realistic example would depend on other libs,</span>
                     <span class="c"># but this &quot;hello world&quot; is pretty simple.</span>
  <span class="n">provides</span> <span class="o">=</span> <span class="n">artifact</span><span class="p">(</span><span class="n">org</span><span class="o">=</span><span class="s">&#39;org.pantsbuild.example&#39;</span><span class="p">,</span>
                      <span class="n">name</span><span class="o">=</span><span class="s">&#39;hello-greet&#39;</span><span class="p">,</span>
                      <span class="n">repo</span><span class="o">=</span><span class="n">public</span><span class="p">,),</span>
<span class="p">)</span>
</pre></div></div>
</p>
<p>This library could depend on other build targets and artifacts; if your
code imports something, that implies a <code>BUILD</code> dependency.</p>
<h3 id="a-test-target">A Test Target</h3>
<p>The <a href="https://github.com/pantsbuild/pants/tree/master/examples/tests/java/org/pantsbuild/example/hello">Pants Java Hello World example
tests</a>
are normal JUnit tests. To run them with Pants, we need a target for
them:</p>
<p>
<div class="md-included-snippet"><div class="codehilite"><pre><span class="n">junit_tests</span><span class="p">(</span>
  <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span>
    <span class="s">&#39;examples/src/java/org/pantsbuild/example/hello/greet&#39;</span><span class="p">,</span>
    <span class="s">&#39;examples/src/resources/org/pantsbuild/example/hello&#39;</span><span class="p">,</span>
  <span class="p">],</span>
<span class="p">)</span>
</pre></div></div>
</p>
<p>As with other targets, this one depends on code that it imports. Thus, a typical test target
depends the library that it tests and perhaps some others (here, <code>junit</code>).
The dependency on <code>junit</code> is a "third party" dependency, a pre-compiled artifact whose source
lives somewhere outside the workspace.</p>
<h3 id="depending-on-a-jar">Depending on a Jar</h3>
<p>The test example depends on a jar, <code>junit</code>. Instead of compiling from
source, Pants invokes ivy to fetch such jars. To reduce the danger of
version conflicts, we use the 3rdparty idiom: we keep references to
these "third-party" jars together in <code>BUILD</code> files under the <code>3rdparty/</code>
directory. Thus, the test has a <code>3rdparty</code> dependency:</p>
<p>
<div class="md-included-snippet"><div class="codehilite"><pre><span class="n">junit_tests</span><span class="p">(</span>
  <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span>
    <span class="s">&#39;examples/src/java/org/pantsbuild/example/hello/greet&#39;</span><span class="p">,</span>
    <span class="s">&#39;examples/src/resources/org/pantsbuild/example/hello&#39;</span><span class="p">,</span>
  <span class="p">],</span>
<span class="p">)</span>
</pre></div></div>
</p>
<p>The <code>BUILD</code> files in <code>3rdparty/</code> have targets like:</p>
<div class="codehilite"><pre><span class="n">jar_library</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;junit&#39;</span><span class="p">,</span>
            <span class="n">jars</span> <span class="o">=</span> <span class="p">[</span>
              <span class="n">jar</span><span class="p">(</span><span class="n">org</span><span class="o">=</span><span class="s">&#39;junit&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;junit-dep&#39;</span><span class="p">,</span> <span class="n">rev</span><span class="o">=</span><span class="s">&#39;4.11&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">with_sources</span><span class="p">(),</span>
            <span class="p">],</span>
            <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span>
              <span class="s">&#39;:hamcrest-core&#39;</span><span class="p">,</span>
            <span class="p">],</span>
           <span class="p">)</span>
</pre></div>


<p>Those <a pantsref="bdict_jar"><code>jar()</code> things</a> are references to public jars.
You can read more about
<a href="3rdparty_jvm.html">JVM 3rdparty dependencies</a>.</p>
<h2 id="the-usual-commands-jvm">The Usual Commands: JVM</h2>
<p><strong>Make sure code compiles and tests pass:</strong></p>
<p>Use the <code>test</code> goal with the targets you're interested in. If they are test targets,
Pants runs the tests. If they aren't test targets, Pants still compiles them since it knows it
must compile before it can test.</p>
<div class="codehilite"><pre><span class="nv">$ </span>./pants <span class="nb">test </span>examples/src/java/org/pantsbuild/example/hello/:: examples/tests/java/org/pantsbuild/example/hello/::
</pre></div>


<p>Assuming you use <code>junit_test</code> targets, output from the <code>junit</code> run is written to
<code>.pants.d/test/junit/</code>; you can see it on the console with <code>--output-mode=ALL</code>:</p>
<div class="codehilite"><pre><span class="nv">$ </span>./pants test.junit --output-mode<span class="o">=</span>ALL examples/tests/java/org/pantsbuild/example/hello::
</pre></div>


<p><strong>Run just that one troublesome test class:</strong> (assuming a JUnit test;
other frameworks use other flags)</p>
<div class="codehilite"><pre><span class="nv">$ </span>./pants test.junit --test<span class="o">=</span>org.pantsbuild.example.hello.greet.GreetingTest examples/tests/java/org/pantsbuild/example/hello/::
</pre></div>


<p><strong>Packaging Binaries</strong></p>
<p>To create a <a pantsref="jvm_bundles">bundle</a> (a binary and its dependencies, perhaps
including helper files):</p>
<div class="codehilite"><pre><span class="nv">$ </span>./pants bundle --bundle-jvm-archive<span class="o">=</span>zip examples/src/java/org/pantsbuild/example/hello/main
   ...lots of build output...
08:50:54 00:02       <span class="o">[</span>create-monolithic-jar<span class="o">]</span>
08:50:54 00:02         <span class="o">[</span>add-internal-classes<span class="o">]</span>
08:50:54 00:02         <span class="o">[</span>jar-tool<span class="o">]</span>
                   created dist/hello-example.zip
08:50:54 00:02     <span class="o">[</span>dup<span class="o">]</span>
08:50:54 00:02     <span class="o">[</span>apk<span class="o">]</span>
08:50:54 00:02       <span class="o">[</span>apk-bundle<span class="o">]</span>
               SUCCESS
<span class="err">$</span>
</pre></div>


<p>This generates a zipfile with runnable contents; instead of a zipfile, we could have put the
contents a directory tree, a giant jar, or something else.
<a pantsref="jvm_bundles">Learn more about bundles</a>.</p>
<h2 id="toolchain">Toolchain</h2>
<p>Pants uses <a href="http://ant.apache.org/ivy/">Ivy</a> to resolve <code>jar</code> dependencies. To change how Pants
resolves these, configure <code>resolve.ivy</code>.</p>
<p>Pants uses <a href="https://github.com/martylamb/nailgun">Nailgun</a> to speed up compiles. Nailgun is a
JVM daemon that runs in the background. This means you don't need to start up a JVM and load
classes for each JVM-based operation. Things go faster.</p>
<p>Pants uses Zinc, a dependency tracking compiler facade that supports sub-target incremental
compilation for Java and Scala.</p>
<h2 id="java9-vs-java8-which-java">Java9 vs Java8, Which Java</h2>
<p>Pants first looks through any JDKs specified by the <code>paths</code> map in pants.ini's jvm-distributions
section, eg:</p>
<div class="codehilite"><pre><span class="k">[jvm-distributions]</span>
<span class="na">paths</span> <span class="o">=</span> <span class="s">{</span>
<span class="s">    &#39;macos&#39;: [</span>
<span class="s">      &#39;/Library/Java/JavaVirtualMachines/jdk-9.0.4.jdk&#39;,</span>
<span class="s">      &#39;/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk&#39;,</span>
<span class="s">    ],</span>
<span class="s">    &#39;linux&#39;: [</span>
<span class="s">      &#39;/usr/java/jdk1.8.0_152&#39;,</span>
<span class="s">    ]</span>
<span class="s">  }</span>
</pre></div>


<p>If no JVMs are found there, Pants uses the first Java it finds in <code>JDK_HOME</code>, <code>JAVA_HOME</code>,
or <code>PATH</code>. If no <code>paths</code> are specified in pants.ini, you can use JDK_HOME to set the Java version
for just one pants invocation:</p>
<div class="codehilite"><pre><span class="nv">$ JDK_HOME</span><span class="o">=</span>/usr/lib/jvm/java-1.8.0-openjdk-amd64 ./pants ...
</pre></div>


<p>If you sometimes need to compile some code in Java 8 and sometimes Java 9, you can define
jvm-platforms in pants.ini, and set what targets use which platforms. For example, in pants.ini:</p>
<div class="codehilite"><pre><span class="k">[jvm-platform]</span>
<span class="err">default_platform:</span> <span class="err">java8</span>
<span class="err">platforms:</span> <span class="err">{</span>
    <span class="err">&#39;java7&#39;:</span> <span class="err">{&#39;source&#39;:</span> <span class="err">&#39;7&#39;,</span> <span class="err">&#39;target&#39;:</span> <span class="err">&#39;7&#39;,</span> <span class="err">&#39;args&#39;:</span> <span class="err">[]</span> <span class="err">},</span>
    <span class="err">&#39;java8&#39;:</span> <span class="err">{&#39;source&#39;:</span> <span class="err">&#39;8&#39;,</span> <span class="err">&#39;target&#39;:</span> <span class="err">&#39;8&#39;,</span> <span class="err">&#39;args&#39;:</span> <span class="err">[]</span> <span class="err">},</span>
    <span class="err">java9&#39;:</span> <span class="err">{&#39;source&#39;:</span> <span class="err">&#39;9&#39;,</span> <span class="err">&#39;target&#39;:</span> <span class="err">&#39;9&#39;,</span> <span class="err">&#39;args&#39;:</span> <span class="err">[]</span> <span class="err">},</span>
  <span class="err">}</span>
</pre></div>


<p>And then in a BUILD file:</p>
<div class="codehilite"><pre><span class="n">java_library</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;my-library&#39;</span><span class="p">,</span>
  <span class="n">sources</span><span class="o">=</span><span class="n">globs</span><span class="p">(</span><span class="s">&#39;*.java&#39;</span><span class="p">),</span>
  <span class="n">platform</span><span class="o">=</span><span class="s">&#39;java8&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>


<p>You can also override these on the cli:</p>
<div class="codehilite"><pre>./pants compile --jvm-platform-default-platform<span class="o">=</span>java9 examples/src/java/org/pantsbuild/example/hello/main
</pre></div>


<p>If you want to set the <code>-bootclasspath</code> (or <code>-Xbootclasspath</code>) to use the
appropriate java distribution, you can use the <code>$JAVA_HOME</code> symbol in the
<code>args</code> list. For example:</p>
<div class="codehilite"><pre><span class="k">[jvm-platform]</span>
<span class="err">default_platform:</span> <span class="err">java8</span>
<span class="err">platforms:</span> <span class="err">{</span>
    <span class="err">&#39;java7&#39;:</span> <span class="err">{&#39;source&#39;:</span> <span class="err">&#39;7&#39;,</span> <span class="err">&#39;target&#39;:</span> <span class="err">&#39;7&#39;,</span> <span class="err">&#39;args&#39;:</span> <span class="err">[&quot;-C-bootclasspath:$JAVA_HOME/jre/lib/resources.jar:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/sunrsasign.jar:$JAVA_HOME/jre/lib/jsse.jar:$JAVA_HOME/jre/lib/jce.jar:$JAVA_HOME/jre/lib/charsets.jar:$JAVA_HOME/jre/lib/jfr.jar:$JAVA_HOME/jre/classes&quot;]</span> <span class="err">},</span>
  <span class="err">}</span>
</pre></div>


<p>Your <code>-bootclasspath</code> should be designed to work with any compatible version of
the JVM that might be used. If you make use of <code>[jvm-distributions]</code> and have
strict control over what jvm installations are used by developers, this means you
probably only have to make it work for one version of the JDK. Otherwise, you
should design your bootclasspath to reference the union of all possible jars
you might need to pull in from different JVMs (any paths that aren't available
will simply be ignored by java).</p>
<p><strong>Note:</strong> Currently, pants is known to work with OpenJDK and Oracle JDK version 7 or greater.</p>
<p><a pantsmark="jvm_bundles"></a></p>
<h2 id="bundles-deploy-able-runnable-file-trees">Bundles: Deploy-able Runnable File Trees</h2>
<p>You can enjoy your web service on your development machine's
<code>localhost</code>, but to let other people enjoy it, you probably want to copy
it to a server machine. With Pants, the easiest way to do this is to
create a <em>bundle</em>: a directory tree of <code>.jar</code> and helper files.</p>
<p>Our "hello world" sample application needs a configuration file to run
correctly. (You can try to run without the configuration file, but the
program crashes immediately.) We define a <code>jvm_app</code> that represents a
runnable binary and "bundles" of extra files:</p>
<p>
<div class="md-included-snippet"><div class="codehilite"><pre><span class="c"># Note that the target has no explicit name, so it defaults to the name</span>
<span class="c"># of the directory, in this case &#39;main&#39;.</span>
<span class="n">jvm_app</span><span class="p">(</span>
  <span class="n">basename</span> <span class="o">=</span> <span class="s">&#39;hello-example&#39;</span><span class="p">,</span>
  <span class="n">dependencies</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;:main-bin&#39;</span>
  <span class="p">],</span>
  <span class="n">bundles</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">bundle</span><span class="p">(</span><span class="n">relative_to</span><span class="o">=</span><span class="s">&#39;config&#39;</span><span class="p">,</span> <span class="n">fileset</span><span class="o">=</span><span class="n">globs</span><span class="p">(</span><span class="s">&#39;config/*&#39;</span><span class="p">))</span>
  <span class="p">]</span>
<span class="p">)</span>
</pre></div></div>
</p>
<p>Here, we keep the extra files in a subdirectory, <code>config/</code> so that they
don't clutter up this directory. (In this simple example, there's just
one file, so there isn't actually much clutter.) By using the
<a pantsref="bdict_bundle"><code>bundle</code></a>'s
<code>relative_to</code> parameter, we "strip off" that
subdirectory; in the generated bundle, these extra files will be in the
top directory.</p>
<p>(If you want to set up a tree of static files but don't need it to be
runnable, you can define a <code>jvm_app</code> target with bundles (and/or
resources) but whose <code>jvm_binary</code> has no source or main; the resulting
bundle will have the files you want (along with a couple of
not-so-useful stub <code>.jar</code> files).)</p>
<h3 id="generating-a-bundle">Generating a Bundle</h3>
<p>Invoke <code>./pants bundle</code> on a JVM app or JVM binary target:</p>
<div class="codehilite"><pre><span class="nv">$ </span>./pants bundle examples/src/java/org/pantsbuild/example/hello/main:main
</pre></div>


<p>With options, you can tell Pants to archive the bundle in a zip, a tar, and some other common
formats. See the <a pantsref="oref_goal_bundle">bundle help</a> for built-in choices.</p>
<h3 id="contents-of-a-bundle">Contents of a Bundle</h3>
<p>The generated bundle is basically a directory tree containing <code>.jar</code>s
and extra files. The <code>.jar</code> in the top-level directory has a manifest so
you can run it with <code>java -jar</code>:</p>
<div class="codehilite"><pre><span class="nv">$ </span><span class="nb">cd </span>dist/hello-example-bundle/
<span class="nv">$ </span>java -jar hello-example.jar
16:52:11 INFO : Hello, world!
</pre></div>


<p>The "bundle" is basically a tree of files:</p>
<div class="codehilite"><pre><span class="nv">$ </span><span class="nb">cd </span>dist/hello-example-bundle/
<span class="nv">$ </span>find .
.
./greetee.txt
./hello-example.jar
./libs
<span class="nv">$ </span>jar -tf hello-example.jar
META-INF/
META-INF/MANIFEST.MF
com/
org/pantsbuild/
org/pantsbuild/example/
org/pantsbuild/example/hello/
org/pantsbuild/example/hello/main/
org/pantsbuild/example/hello/main/HelloMain.class
org/pantsbuild/example/
org/pantsbuild/example/hello/
org/pantsbuild/example/hello/world.txt
org/pantsbuild/example/hello/greet/
org/pantsbuild/example/hello/greet/Greeting.class
</pre></div>


<p>That <code>greetee.txt</code> file came from the <code>bundles=</code> parameter.
The <code>libs/</code> directory contains 3rdparty jars (if any). The <code>jar</code> in the top directory
contains code compiled for this target.</p>
<h3 id="deploying-a-bundle">Deploying a Bundle</h3>
<p>Instead of just creating a directory tree, you can specify <code>bundle --bundle-jvm-archive=zip</code> to
<code>./pants bundle</code> to generate an archive file (a <code>.zip</code>, monolithic <code>.jar</code>, or some other
format) instead.</p>
<p>To use such an archive, put it where you want it, unpack it, and run:</p>
<div class="codehilite"><pre><span class="nv">$ </span>./pants bundle --bundle-jvm-archive<span class="o">=</span>zip examples/src/java/org/pantsbuild/example/hello/main
    ...lots of build output...
10:14:26 00:01       <span class="o">[</span>create-monolithic-jar<span class="o">]</span>
10:14:26 00:01         <span class="o">[</span>add-internal-classes<span class="o">]</span>
10:14:26 00:01         <span class="o">[</span>jar-tool<span class="o">]</span>
                   created dist/hello-example.zip
10:14:26 00:01     <span class="o">[</span>dup<span class="o">]</span>
10:14:26 00:01     <span class="o">[</span>apk<span class="o">]</span>
10:14:26 00:01       <span class="o">[</span>apk-bundle<span class="o">]</span>
               SUCCESS
<span class="nv">$ </span><span class="c"># let&#39;s use it:</span>
<span class="nv">$ </span>mkdir tmp; <span class="nb">cd </span>tmp
<span class="nv">$ </span>unzip ../dist/hello-example.zip
Archive:  ../dist/hello-example.zip
  inflating: greetee.txt
  inflating: hello-example.jar
<span class="nv">$ </span>java -jar hello-example.jar
Hello, Bundled-File World!
Hello, Resource World!
<span class="err">$</span>
</pre></div>


<h2 id="omitting-or-shading-the-contents-of-a-binary">Omitting or Shading the Contents of a Binary</h2>
<h3 id="omitting">Omitting</h3>
<p>Sometimes you want to leave some files out of your binary.</p>
<p>You can omit jars from the binary by means of the <code>jvm_binary</code>'s <code>deploy_excludes</code> parameter.
For example, if you're making a binary to run on Hadoop and there are some "standard jars"
already on the destination machines, you can list those in <code>deploy_excludes</code>.</p>
<p>More generally, you can omit files from the binary jar with <code>deploy_jar_rules</code>. For example, a
3rdparty dependency might have a transitive dependency with a bad manifest file. If you try to run
the jar you might get <code>Invalid signature file digest for Manifest main attributes</code>. If you don't
actually use the code in that transitive dependency, you might work around the error by omitting
the dependency.</p>
<p>To tell Pants to omit some files from the binary, set the <code>deploy_jar_rules</code> parameter of
<a pantsref='bdict_jvm_binary'><code>jvm_binary</code></a> to a <a pantsref='bdict_jar_rules'><code>jar_rules</code></a>.
E.g., to omit all files containing the regexp <code>Greeting</code>, you might set</p>
<div class="codehilite"><pre><span class="n">deploy_jar_rules</span><span class="o">=</span><span class="n">jar_rules</span><span class="p">(</span><span class="n">rules</span><span class="o">=</span><span class="p">[</span><span class="n">Skip</span><span class="p">(</span><span class="s">&#39;Greeting&#39;</span><span class="p">)])</span>
</pre></div>


<p>After building our <code>hello</code> example, if we check the binary jar's contents, there is no
<code>Greeting.class</code> (and running that jar crashes; we omitted a class this binary needs):</p>
<div class="codehilite"><pre><span class="nv">$ </span>./pants binary examples/src/java/org/pantsbuild/example/hello/main:main
<span class="nv">$ </span>jar -tf dist/hello-example.jar
META-INF/
META-INF/MANIFEST.MF
com/
org/pantsbuild/
org/pantsbuild/example/
org/pantsbuild/example/hello/
org/pantsbuild/example/hello/main/
org/pantsbuild/example/hello/main/HelloMain.class
org/pantsbuild/example/
org/pantsbuild/example/hello/
org/pantsbuild/example/hello/world.txt
<span class="err">$</span>
</pre></div>


<h3 id="shading">Shading</h3>
<p>Sometimes you have dependencies that have conflicting package or class names. This typically occurs
in the following scenario: Your jvm_binary depends on a 3rdparty library A (rev 1.0), and a 3rdparty
library B (rev 1.3). It turns out that A happens to also depend on B, but it depends on B (rev 2.0),
which is backwards-incompatible with rev 1.3. Now B (1.3) and B (2.0) define different versions of
the same classes, with the same fully-qualified class names, and you're pulling them all onto the
classpath for your project.</p>
<p>This is where shading comes in: you can rename the fully-qualified names of the classes that
conflict, typically by applying a prefix (eg, <code>__shaded_by_pants__.org.foobar.example</code>).</p>
<p>Pants uses jarjar for shading, and allows shading rules to be specified on <code>jvm_binary</code> targets with
the <code>shading_rules</code> argument. The <code>shading_rules</code> argument is a list of rules. Available rules
include: <a pantsref='bdict_shading_relocate'><code>shading_relocate</code></a>,
<a pantsref='bdict_shading_exclude'><code>shading_exclude</code></a>,
<a pantsref='bdict_shading_relocate_package'><code>shading_relocate_package</code></a>, and
<a pantsref='bdict_shading_exclude_package'><code>shading_exclude_package</code></a>.</p>
<p>The order of rules in the list matters, as typical of shading
logic in general.</p>
<p>These rules are powerful enough to take advantage of jarjar's more
advanced syntax, like using wildcards in the middle of package
names. E.g., this syntax works:</p>
<div class="codehilite"><pre><span class="c"># Destination pattern will be inferred to be</span>
<span class="c"># __shaded_by_pants__.com.@1.foo.bar.@2</span>
<span class="n">shading_relocate</span><span class="p">(</span><span class="s">&#39;com.*.foo.bar.**&#39;</span><span class="p">)</span>
</pre></div>


<p>Which can also be done by:</p>
<p>:::python
   shading_relocate_package('com.*.foo.bar')</p>
<p>The default shading prefix is <code>__shaded_by_pants__</code>, but you can change it:</p>
<div class="codehilite"><pre><span class="n">shading_relocate_package</span><span class="p">(</span><span class="s">&#39;com.foo.bar&#39;</span><span class="p">,</span> <span class="n">shade_prefix</span><span class="o">=</span><span class="s">&#39;__my_prefix__.&#39;</span><span class="p">)</span>
</pre></div>


<p>You can rename a specific class:</p>
<div class="codehilite"><pre><span class="n">shading_relocate</span><span class="p">(</span><span class="s">&#39;com.example.foo.Main&#39;</span><span class="p">,</span> <span class="s">&#39;org.example.bar.NotMain&#39;</span><span class="p">)</span>
</pre></div>


<p>If you want to shade everything in a package except a particular file (or subpackage), you can use
the <a pantsref='bdict_shading_exclude'><code>shading_exclude</code></a> rule.</p>
<div class="codehilite"><pre><span class="n">shading_exclude</span><span class="p">(</span><span class="s">&#39;com.example.foobar.Main&#39;</span><span class="p">)</span> <span class="c"># Omit the Main class.</span>
<span class="n">shading_exclude_package</span><span class="p">(</span><span class="s">&#39;com.example.foobar.api&#39;</span><span class="p">)</span> <span class="c"># Omit the api subpackage.</span>
<span class="n">shading_relocate_package</span><span class="p">(</span><span class="s">&#39;com.example.foobar&#39;</span><span class="p">)</span>
</pre></div>


<p>Again, order matters here: excludes have to appear <strong>first</strong>.</p>
<p>To see an example, take a look at <code>testprojects/src/java/org/pantsbuild/testproject/shading/BUILD</code>,
and try running</p>
<div class="codehilite"><pre>./pants binary testprojects/src/java/org/pantsbuild/testproject/shading
jar -tf dist/shading.jar
</pre></div>


<h2 id="target-scopes">Target Scopes</h2>
<h3 id="overview">Overview</h3>
<p>Pants supports marking targets with one or more <code>scope</code> values which the JVM backend will use to filter
dependency subgraphs at compiletime and runtime. Scopes are also used for unused dependency
detection: only <code>default</code> scoped targets are eligible to be considered as "unused" deps.</p>
<h3 id="correspondence-with-other-build-systems">Correspondence with other build systems</h3>
<p>Scopes in pants are similar to scopes in other build systems, with the fundamental difference
that they apply to targets (the "nodes" of the build graph), rather than to dependency "edges".
The reason that Pants differs in this regard is that, in a monorepo, it is strongly encouraged
to make changes to your dependency targets (which benefits all consumers) rather than to work
around an issue in a dependency by making a local change to your target.</p>
<h3 id="scope-values">Scope values</h3>
<p>Pants' built in scopes are:</p>
<ul>
<li><code>default</code>: The "default" scope when a scope is not specified on a target. <code>default</code> targets are
  included on classpaths at both compiletime and runtime, and are the only targets eligible for
  unused dep detection.</li>
<li><code>compile</code>: Indicates that a target is only used at compiletime, and should not be included
  in runtime binaries or bundles. javac annotation processors or scalac macros are good examples
  of compiletime-only dependencies.</li>
<li><code>runtime</code>: Indicates that a target is only used at runtime, and should not be presented to the
  compiler. Targets which are only used via JVM reflection are good examples of runtime-only
  dependencies.</li>
<li><code>test</code>: Indicates that a target is used when running tests. This scope is typically used in
  addition to another scope (e.g.: <code>scope='compile test'</code>). Targets which are are provided by an
  external execution environment are good examples of compile+test dependencies.</li>
<li><code>forced</code> <em>(available from pants 1.1.0)</em>: The <code>forced</code> scope is equivalent to the <code>default</code> scope, but additionally indicates
  that a target is not eligible to be considered an "unused" dependency. It is sometimes necessary
  to mark a target <code>forced</code> due to false positives in the static analysis used for unused
  dependency detection; if possible, you should always prefer to mark a target <code>runtime</code> or
  <code>compile</code> if that more accurately describes their usage.</li>
</ul>
<h3 id="setting-target-scopes">Setting target scopes</h3>
<p>To set the scope of a target, you should generally prefer to pass the <code>scope</code> parameter for
that target:</p>
<div class="codehilite"><pre><span class="n">java_library</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;lib&#39;</span><span class="p">,</span>
  <span class="o">..</span><span class="p">,</span>
  <span class="n">scope</span><span class="o">=</span><span class="s">&#39;runtime&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>


<p>Multiple scopes can be specified. The equivalent of Maven's <code>provided</code> scope can be expressed by
specifying both compile and test scopes.</p>
<div class="codehilite"><pre><span class="n">java_library</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;lib&#39;</span><span class="p">,</span>
  <span class="o">..</span><span class="p">,</span>
  <span class="n">scope</span><span class="o">=</span><span class="s">&#39;compile test&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>


<p>If the scope of a target is not matched for a particular context, the entire subgraph represented
by the dependency will be pruned. This means that if a dependency 'B' of a target 'A' is marked
<code>compile</code> (for example), the dependency targets of 'B' will only be included at compiletime (unless
'A' has other dependency paths to those targets).</p>
<p>One effect of this behavior is that you can introduce intermediate aliases to "re-scope" a target
when consumers need to use it in multiple ways:</p>
<div class="codehilite"><pre><span class="c"># An alias of `:lib` which consumers can use to indicate that they only need it at compile time.</span>
<span class="n">target</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;lib-compile&#39;</span><span class="p">,</span>
  <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;:lib&#39;</span><span class="p">],</span>
  <span class="n">scope</span><span class="o">=</span><span class="s">&#39;compile&#39;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">java_library</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;lib&#39;</span><span class="p">,</span>
  <span class="o">..</span><span class="p">,</span>
  <span class="n">scope</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>


<p>Finally, for cases where only a few consumers need to "re-scope" a particular target, it is possible
to change the scope of a single edge locally to a consumer via the <code>scoped</code> macro (which, under the
hood, uses the previous technique of creating an intermediate alias):</p>
<div class="codehilite"><pre><span class="n">java_library</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;lib&#39;</span><span class="p">,</span>
  <span class="n">dependencies</span><span class="o">=</span><span class="p">[</span>
    <span class="n">scoped</span><span class="p">(</span><span class="s">&#39;src/java/the/best/lib&#39;</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="s">&#39;compile&#39;</span><span class="p">),</span>
    <span class="s">&#39;src/scala/some/other/lib&#39;</span><span class="p">,</span>
  <span class="p">],</span>
<span class="p">)</span>
</pre></div>


<h2 id="dependency-hygiene">Dependency Hygiene</h2>
<p>As the set of targets in a repository grows larger, it becomes increasingly important that they
observe good dependency hygiene. In particular, following
<a href="../../../../../../src/docs/build_files.html">the 1:1:1 rule</a> helps keep useful code self-contained. But even
while observing 1:1:1, it's possible to declare and use dependencies that add little or no benefit
for a target.</p>
<p>For example: a particularly large target may expose many different APIs. In cases where other
targets depend on the large target, they might need only a fraction of those APIs. But because
they can't declare a dependency on a smaller subset of the large target, they are forced to
build the entire dependency. Even in the presence of distributed builds and caching, this slows
down your build!</p>
<p>To help users address these problems for JVM targets, pants has a <code>dep-usage.jvm</code> task which
supports scoring and summarizing the fractions of each dependency that a target uses.</p>
<h3 id="for-local-analysis">For local analysis</h3>
<p>In the default output mode ("summary" mode) the <code>dep-usage.jvm</code> task outputs targets ordered by
a simple 'badness' score. The "badness" score is intended to indicate both how easy the dependency
would be to remove (based on the maximum fraction used by each dependee) and how valuable it would
be remove (based on a estimate of the transitive cost to build the dep).</p>
<p>Stat explanation:</p>
<ul>
<li><code>max_usage</code>: fraction of the dependency target is being used. 0 means the target is safe to drop.</li>
<li><code>cost_transitive</code>: the cost to bring in this target including its transitive dependencies in the build process</li>
<li>
<p><code>badness</code>: <code>cost_transitive/max_usage</code>, so the lower the better.</p>
<p>:::shell
$ ./pants -q dep-usage.jvm examples/src/scala/org/pantsbuild/example/hello/:
[
  {"badness": 0, "max_usage": 1.0, "cost_transitive": 0, "target": "//:scala-library-synthetic"},
  {"badness": 8872, "max_usage": 0.125, "cost_transitive": 1109, "target": "examples/src/java/org/pantsbuild/example/hello/greet:greet"},
  {"badness": 16410, "max_usage": 0.1, "cost_transitive": 1641, "target": "examples/src/scala/org/pantsbuild/example/hello/welcome:welcome"}
]</p>
</li>
</ul>
<p>The above example indicates that within the scope of the scala examples, the
<code>examples/src/scala/org/pantsbuild/example/hello/welcome</code> target is the worst dependency. This is
because it has a high transitive "cost" to build, and sees a maximum of 10% usage by its dependees.</p>
<h3 id="for-global-analysis">For global analysis</h3>
<p>The summary mode is great when users want to inspect their own targets. But for more in-depth
analysis, disabling summary mode (by passing the <code>--no-summary</code> flag) will output raw usage data
for each dependency edge. This mode does no aggregation, so using it effectively usually means
doing analytics or graph analysis with an external tool.</p>
<h2 id="compiler-plugins">Compiler Plugins</h2>
<p>Pants has robust support for both developing and using compiler plugins for
javac and scalac.  For more details:</p>
<ul>
<li><a href="javac/plugin/README.html">javac plugins with Pants</a>.</li>
<li><a href="../../../../scala/org/pantsbuild/example/scalac/plugin/README.html">scalac plugins with Pants</a>.</li>
</ul>
<h2 id="further-reading">Further Reading</h2>
<p>If you use Scala, see
<a href="../../../../scala/org/pantsbuild/example/README.html">Scala Projects with Pants</a>.</p>
<p>If you know Maven and want to know Pants equivalents, see
<a href="from_maven.html">Pants for Maven Experts</a>.</p>
